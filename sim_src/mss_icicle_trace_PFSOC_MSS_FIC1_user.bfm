memmap FIC1_BASE 0x3f00000000;
constant NUMBER_BYTE 63;
int DATA0;
int DATA1;
int DATA2;
int DATA3;
int CYCLE_CNT;
int TEMP_ADDR;


procedure main;
	# Initialize; sim_check_against_bfm expects the exact data sequence
	# generated by the $RAND LFSR.
	set TEMP_ADDR 0
	setrand 0x12345678

	# Wait for receiver to lock on. Any data we write before that will get
	# lost, making it more difficult to check for correctness. Trace data will
	# only be written after the debugger has configured the trace
	# infrastructure, so this mirrors the actual use case.
	#
	# Wait in a loop to avoid "bfm command timeout" errors...
	loop CYCLE_CNT 0 41 1
		wait 100
	endloop

	# Write (CYCLE_CNT + 1) * 16 Bytes as 64-bit double bursts
	loop CYCLE_CNT 0 NUMBER_BYTE 1
		set DATA0 $RAND;
		set DATA1 $RAND;
		set DATA2 $RAND;
		set DATA3 $RAND;
		writemult64 w FIC1_BASE TEMP_ADDR DATA1 DATA0 DATA3 DATA2;
		set TEMP_ADDR TEMP_ADDR + 16
	endloop

	# Write (CYCLE_CNT + 1) * 8 Bytes as 64-bit single writes
	loop CYCLE_CNT 0 NUMBER_BYTE 1
		set DATA0 $RAND;
		set DATA1 $RAND;
		write64 w FIC1_BASE TEMP_ADDR DATA1 DATA0;
		set TEMP_ADDR TEMP_ADDR + 8
	endloop

	# TODO: Check more access patterns (burst size is limited by "Only first 8
	# parameters can refer to a variable" error message, and I cannot figure out
	# how to send 32-bit transactions). If the modifications change the number
	# of Bytes that are written in total, modify the gSequenceLength parameter
	# of sim_check_against_bfm.
	#
	# Refer to axi_to_aurora_tb for a VHDL testbench that does not have these
	# limitations.

	print "SENT %d BYTES", ((NUMBER_BYTE + 1) * (16 + 8))
return
